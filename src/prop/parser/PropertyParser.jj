options{  STATIC = true;
  UNICODE_INPUT = true;}PARSER_BEGIN(PropParser)package prop.parser;

import java.io.StringReader;

import prop.*;

public class PropParser{

  public static StateProp parse(String s) throws ParseException  {
    PropParser.ReInit(new StringReader(s));
    return PropParser.start();  }}PARSER_END(PropParser)TOKEN :{  < #SPACE : [" ", "\r", "\t", "\n"] >
| < DELIM : (<SPACE >)+ >
}
TOKEN :
{
  < NOT : "!" >
| < AND : "/\\" | "&&" >
| < OR : "\\/" | "||" >
| < TRUE : "true" >
| < FALSE : "false" >
| < PROB : "P" >
}TOKEN : {  < NEXT : "X" >| < EVENTUALLY : "<>" >| < ALWAYS : "[]" >| < UNTIL : "U" >}TOKEN :{  < COMP : "<=" | "<" | ">=" |">" >
| <DIGIT : ["0" - "9"] >
| <INTEGER : (<DIGIT>)+ >
| <FLOAT : (<DIGIT>)+ "." (<DIGIT>)+>
| <IDENT : ["A" - "Z", "a" -"z", "_"](["A" - "Z", "a" -"z" ,"0"-"9", "_"])* >}

StateProp start() :{  StateProp p;
}{
  [<DELIM >]
  p = stateFormula()
  [<DELIM >]
  {    return p;  }}

StateProp stateFormula() :
{
  StateProp p1,p2;
}
{
  p1 = stateTerm()
  (      LOOKAHEAD(2)	  [< DELIM >] < OR > [< DELIM >]
	  p2 = stateTerm()
	  {
	    p1 = new PropOr(p1,p2);
	  }
  )*
  {    return p1;
  }
}
StateProp stateTerm() :
{
  StateProp p1,p2;}
{
  p1 = stateElement()  (    LOOKAHEAD(2)    [< DELIM >] < AND > [< DELIM >]
    p2 = stateElement()
  {    p1 = new PropAnd(p1,p2);
  }
  )*
  {    return p1;
  }}
StateProp stateElement() :
{
  StateProp p;
  Token t;
}
{ 
  "(" [< DELIM >]
  p = stateFormula()
  [< DELIM >] ")"
  { return p; }
| < TRUE >
  {
    return new PropTrue();
  }
| t = < IDENT >
  {
	return new PropAtom(t.image);
  }  }
